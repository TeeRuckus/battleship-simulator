CLASS: submarineClass

PUBLIC CLASS CONSTANTS:
    STEEL := "STEEL"
    ALLY := "ALLOY"
    TTNM := "TITANIUM"
    TOL := 0.001

CLASS FIELDS:
    serialNum (Real)
    year (Interger)
    hull (string)
    maxDepth (Real)

COSTRUCTORS:

Defualt:
    IMPORT: none
    EXPORT: none
    ASSERTION: a submarine with a serial number of 123.456, commisioned in
                1950, with an engine hull of Titanium  with a maxium depth of
                500.0 is a valid defualt state

    ALGORITHM:
        serialNum := 123.456
        year := 1950
        hull := TTNM
        maxDepth := 500.0

Alternate
    IMPORT: inSerialNum (Real), inYear (Interger), inHull (String),
            inMaxDepth (Real)
    EXPORT: none
    ASSERTIONS: creates an object if the imports are valid, otherwise it will
                FAIL

    ALGORITHM:
        IF (validateSerialNum <- inSerialNum) THEN
            IF (validateYear <- inYear) THEN
                IF (validateHull <- inHull) THEN
                    IF (validateMaxDepth <- inMaxDepth) THEN

                        serialNum := inSerialNum
                        year := inYear
                        hull := inHull
                        maxDepth := inMaxDepth
        ELSE
            FAIL
        END IF ELSE

Copy:
    IMPORT: inSubMarine (SubMarineClass)
    EXPORT: none
    ASSERTION: creates an object which is identical to the imported object

    ALGORITHM:
        serialNum := inSubMarine.getSerialNum <- none
        year := inSubMarine.getYear <- none
        hull := inSubMarine.getHull <- none
        maxDepth := inSubMarine.getMaxDepth <- none

ACCESSORS

SUBMODULES: getSerialNum
    IMPORT: none
    EXPORT: serialNum
    ASSERTION: returns the last set serial number set

SUBMODULE: getYear
    IMPORT: none
    EXPORT: year
    ASSERTION: returns the last set commision year

SUBMODULE: get getHull
    IMPORT: none
    EXPORT: hull
    ASSERTION: returns the last set hull

SUBMODULE: getMaxDepth
    IMPORT: none
    EXPORT: maxDepth
    ASSERTION: returns the last set max depth

MUTATORS:

SUBMODULE: setSerialNum
    IMPORT: inSerialNum (Real)
    EXPORT: none
    ASSERTION: sets the serial number to inSerialNum if it's valid, otherwise
                it fails

    ALGORITHM:
        IF (validateSerialNum <- inSerialNum) THEN
            serialNum := inSerialNum
        ELSE
            FAIL
        END IF ELSE


SUBMODULE: setYear
    IMPORT: inYear (interger)
    EXPORT: none
    ASSERTION: set year to inYear if it's valid, otherwise it will fail

    ALGORITHM:
        IF (validateYear <- inYear) THEN
            year := inYear
        ELSE
            FAIL
        END IF ELSE

SUBMODULE: setHull
    IMPORT: inHull (String)
    EXPORT: none
    ASSERTION: set hull to to inHull if it's valid, otherwise it will fail

    ALGORITHM:
        IF (validateHull <- inHull) THEN
            hull := inHull
        ELSE
            FAIL
        END IF ELSE

SUBMODULE: setMaxDepth
    IMPORT: inMaxDepth (Real)
    EXPORT: none
    ASSERTION: set max depth to inMaxDepth if it's valid, otherwise

    ALGORITHM:
        IF (validateMaxDepth <- inMaxdepth) THEN
            maxDepth :=  inMaxDepth
        ELSE
            FAIL
        END IF ELSE

DOING METHODS:

    SUBMODULE: calcTravel (*** I cannot impliment this yet, as my knowledge on
                            how to is limited ***)

PRIVATE SUBMODULES:

    SUBMODULE: validateSerialNum
        IMPORT: inSerialNum (Real)
        EXPORT: isValid (Boolean)
        ASSERTION: validates serial numbers as true whereby its first three
                   digits are between 100 to 200 (inclusive), and the last three
                   digits are between 001 - 999 (inclusive), otherwise it will
                   validate them as false.

        ALGORITHM:
            isValid := FALSE

            inSerialNum := inSerialNum * 1 000
            wholePart := (interger)inSerialNum DIV 1 000
            decimalPart := (interger)inSerialNum MOD 1 000

            IF (validSerialFormat <- inSerialNum, wholePart, decimalPart) THEN
                isValid := TRUE
            END IF

    SUBMODULE: validSerialFormat
        IMPORT: inSerialNum (Real), wholePart (interger), decimalPart (interger)
        EXPORT: isValid (Boolean)
        PURPOSE: to ensure that the serial number is written in this format
                 XXX.YYY and not in any other format.
        ASSERTION: inSerialNum will be true if it's inputed in the following
                   formatting XXX.YYY, otherwise, an error will be thrown to the
                   user

        ALGORITHM:
            isValid := FALSE

            checkDecimalPart := inSerialNum - (Real)(wholePart * 1000)
            IF (AbsouleValueOf(checkDecimalPart - decimalPart) < TOL)
                IF (100 <= wholePart <= 300) THEN
                    IF (1 <= decimalPart <= 999) THEN
                        isValid := TRUE
            END IF

    SUBMODULE: validateYear
        IMPORT: inYear (intergers)
        EXPORT: isValid (Boolean)
        ASSERTION: A commission year between 1950 to 2022 (interger) will be
                   valid, otherwise an error will be thrown to the user

        ALGORITHM:
            isValid := FALSE

            IF ( 1950 <= inYear <= 2022) THEN
                isValid :=   TRUE
            END IF


    SUBMODULE: validateHull
        IMPORT: inHull (String)
        EXPORT: isValid (boolean)
        ASSERTION: it will only validate inHull if it's one of the following
                   three; steel, alloym and titanium.

        ALGORITHM:
            isValid := FALSE
            IF (inHull equals to STEEL or ALY or TTNM) THEN
                isValid := TRUE
            END IF

    SUBMODULE: validateMaxDepth
        IMPORT: inMaxDepth (Real)
        EXPORT: isValid (Boolean)
        ASSERTION: a maxdepth of between -500 - 0 will be validate otherwise, an
                   error will be thrown to the user

        ALGORITHM:
            isValid := FALSE

            IF (-500.0 <= inMaxDepth <= 0) THEN
                isValid := TRUE
            END IF

OTHER METHODS:

SUBMODULE: clone
    IMPORT: none
    EXPORT: cloneSubMarine (Object)
    ASSERTION: returns a cloned object of the current object

    ALGORITHM:
        CONSTRUCT cloneSubmarine USING ALTERNATE CONSTRUCTOR with
            -serialNum
            -year
            -hull
            -maxDepth

SUBMODULE: equals
    IMPORT: inObjct (object)
    EXPORT: isSame (boolean)
    ASSERTION: two submarines are interchangable if they have the same hull, and
                max depth

    ALGORITHM:
        isSame := FALSE
        IF (inObj ISA submarineClass) THEN
            inSubmarine  := (Convert to submarineClass)inObjct
            isSame := (hull EQUALS inSubmarine.getHull <- none) AND
                      (maxDepth EQUALS inSubmarine.getMaxDepth <- none)
        END IF


SUBMODULE: toString
    IMPORT: none
    EXPORT: str
    ASSERTION:

    ALGORITHM:
       str := "The ship " +serialNum+ " was comissioned in " +year+ ", its
               engine has " +cylinders+ " cylinders and runs on " +fuel+ ". It
               is a submarine with a " +hull+ " hull and a max depth of "
                +maxDepth+ "."

SUBMODULE: toFileString
    IMPORT: none
    EXPORT: str
    ASSERTION:

    ALGOTITHM:
        str := "S," +serialNum+ "," +year+ "," +cylinders+ "," +fuel+ "," +hull+
               "," +maxDepth
