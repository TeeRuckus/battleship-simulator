CLASS: shipStorageClass 

PUBLIC CLASS CONSTANTS: 
    (Interger) maxSubCap := 15
    (interger) maxJetCap := 15

CLASS FIELDS:

    (Interger) countSubs 
    (Interger) countJets 
    (ARRAY OF subMarine object) storeSubs [] 
    (ARRAY OF fighterJet object) storeJets []

COSTRUCTORS:

Defualt:
    IMPORT: none
    EXPORT: none
    ASSERTION: count varibales of zero and empty arrays of 15 elements is valid
               defualt sate

    ALGORITHM:
        countSubs := 0 
        countJets := 0 
        storeSubs[] := an EMPTY array of SIZE 15
        storeJets[] := an EMPTY array of SIZE 15

Alternate
    IMPORT: (subMarine object) inSub 
            (fighterJet object) inJet 
    EXPORT: none
    ASSERTIONS: creates an object if the imports are valid in the next array 
                index available, otherwise it will FAIL

    ALGORITHM:

        IF (valiadateStoreSubs <- inSub) THEN
            IF (validateStoreJets <- inJet) THEN
                storeSub[countSubs] := inSub
                storeJet[countJets] := inJet 
                countSubs := countSubs + 1
                countJets := countJets + 1

        ELSE
            FAIL
        END IF ELSE

Copy:
    IMPORT: inShipStorage (shipStorageClass)
    EXPORT: none
    ASSERTION: creates an object which is identical to the imported object

    ALGORITHM:

        storeSubs[] := inShipStorage.getStoreSubs <- none
        storeJets[] := inShipStorage.getStoreJets <- none

ACCESSORS

SUBMODULES: getStoreSubs
    IMPORT: none
    EXPORT: storeSubs (address of storeSubs object in memory) 
    ASSERTION: returns the elements which were last store in storeSubs object

SUBMODULE: getStoreJets
    IMPORT: none
    EXPORT: storeJets (address of storeJets object in memory)
    ASSERTION: returns the elemnts which were last sttore in storeSubs object 

MUTATORS:

SUBMODULE: setStoreSubs
    IMPORT: inStoreSubs (address of inStoreSubs in memory)
    EXPORT: none
    ASSERTION: if the elements and array founf at the specified address is 
               valid. setStoreJets will be valid, otherwise it will fail 

    ALGORITHM:
        IF (validateStoreSubs <- inStoreSubs) THEN 
            storeSubs := inStoreSubs
        ELSE
            FAIL
        END IF ELSE

SUBMODULE: setStoreJets
    IMPORT: inStoreJets (address of inStoreJers in memorty)
    EXPORT: none 
    ASSERTION: if the elements and array found at the specified adress is
               valid. setStoreJets will be valid, otherwise it will fail

    ALGORITHM:
        IF (validateStoreJets <- inStoreJets) THEN
            storeJets := inStoreJets 
        ELSE
            FAIL
        END IF ELSE

SUBMODULE: addSub
    IMPORT: inSub (subMarine object) , countSubs (Interger)
    EXPORT: none
    ASSERTION: a sub will be added to storeSubs if the inSub is valid, and
                storeSubs hasn't exceeded 15 elements 

    ALGORITHM:
        IF (validateSub <- inSub) THEN
            IF (validateSubCap <- countSubs) THEN
                
                storeSubs[countSubs] := inSub

                COMMENT: I am incrementing countSub by 1, to go to the next
                         vaccant index of the storeSub

                countSub := countSubs + 1
        ELSE
            FAIL
        END IF ELSE 
         
SUBMODULE: addJet
    IMPORT: inJet (jetFighter object) , countJets (interger) 
    EXPORT: none
    ASSERTION: a jet will be added to storeJEts if ther inJet is valid, and 
               storeSubs hasn't exceeded 15 elements

    ALGORITHM:
        IF (validateJet <- inJet) THEN 
            IF (validateJetCap <- countJets) THEN 

                storeJets[countJets] := inJet

                COMMENT: I am incemention countJets by 1, to go to the next 
                         vaccant index of the storeJets

                countJets := countJets + 1
        ELSE
            FAIL
        END IF ELSE

DOING METHODS:
    
SUBMODULE: calcTolShips
    IMPORT: countSubs (interger), countJets (integer)
    EXPORT: tolShips

    ALGORITHM:
        
        tolShips := (calcTolSubs <- countSubs) + (calcTolJets <- countJets)          
    
SUBMODULE: calcTolSubs
    IMPORT: countSubs
    EXPORT: tolSubs 
    
    ALGORITHM:
       
        COMMENT: the reason why I subtract 1 is because the other submodules
                 are designed to go to the next index of storeSubs.
                 Hence to get how much ships are avaliable, you have to 
                 subtract 1. But, if the count variables haven't be
                 used (i.e. they're zero) then they're no ships stored, 
                 hence it is 0

        IF (countSubs doesn't EQUAL 0) THEN
            countSubs := countSubs -1 
            tolSubs := countSubs
        ELSE
            tolSubs := countSub
        END IF ELSE    

SUBMODULE: calcTolJets
    IMPORT: countJets
    EXPORT: tolJets
    
    ALOGRITHM:

        COMMENT: the reason why I subtract 1 is because the other submodules
                 are designed to go to the next index of storeSubs.
                 Hence to get how much ships are avaliable, you have to 
                 subtract 1. But, if the count variables haven't be
                 used (i.e. they're zero) then they're no ships stored, 
                 hence it is 0

        IF (countJets doesn't EQUAL) THEN

            countJets := countJets -1
            tolJets := countJets
        ELSE
            tolJets := countSub
        END IF ELSE

PRIVATE SUBMODULES:

SUBMODULE: validateStoreSubs
    IMPORT: inStoreSubs (address of inStoreSubs in memory)
    EXPORT: isValid (Boolean)
    ASSERTION: If the address of inStoreSubs is an array of maxSubCap elements, 
               and it's a SubMarine object it's a valid inStoreSubs

    ALGORITHM:

        isValid := FALSE
        IF (inStoreSubs ISA subMarineClass) THEN
            IF (inStoreSubs LENGTH EQUALS to maxSubCap)               
                isValid := TRUE
            ELSE
                OUTPUT: "ERROR: incorrect storage capacity"
        ELSE
            OUTPUT: "ERROR: not a submarine"

SUBMODULE: validateStoreJets
    IMPORT: inStoreJets (address of inStoreJets in memory)
    EXPORT: isVali (Boolean)
    ASSERTION: if the address of inStoreJets is an array of maxJetCap elements, 
               and it's fighteJet object it's a valid inStoreJet

    ALGORITHM:
        
        isValid := FALSE
        IF (inStoreJets ISA fighterJetClass) THEN 
            IF (inStoreJets LENGTH EQUALS to maxJetCap) THEN
                isValid := TRUE
            ELSE 
                OUTPUT: "ERROR: incorrect storage capacity"
        ELSE
            OUTPUT: "ERROR: not a fighter jet"
        END IF ELSE

SUBMODULE: validateSub
    IMPORT: inObjct (subMarine object)
    EXPORT: isValid (Boolea)
    ASSERTION: if inSub is a subMarine object then it's  valid 

    ALGORITHM:
        
        isValid := FALSE
        IF (inSub ISA subMarineClass) THEN
            isValid := TRUE
        ELSE
            OUTPUT: "ERROR: not a submarine"
        END IF ELSE

SUBMODULE: validateJet
    IMPORT: inObjct (fighterJet object)
    EXPORT: isValid (Boolean)
    ASSERTION: if inJet is a fighterJet object then it's valid

    ALGORITHM:

        isValid := FALSE
        IF (inJet ISA fighterJetClass) THEN
            isValid := TRUE
        ELSE
            OUTPUT: "ERRO: not a fighter Jet"
        END IF ELSE

SUBMODULE: validateSubCap
    IMPORT: countSubs (Integers)
    EXPORT: isValid (Boolean)
    ASSERTION: if countSubs is within maxSubCap then it's valid

    ALGORITHM:
        
        isValid := FALSE 
        IF ( 0 <= countSubs <= maxSubCap ) THEN 
            isValid := TRUE
        ELSE
            OUTPUT: "ERROR: to many subs, the max capacity is" +maxSubCap+ "."
        END ELSE IF 

SUBMODULE: validateJetCap
    IMPORT: countJets (Integer)
    EXPORT: isValid (Boolean)
    ASSERTION: if countJets is within maxJetCap then it's valid

    ALGORITHM:
        
        isValid := FALSE
        IF ( 0 <= countJets <= maxJetCap) THEN
            isValid := TRUE 
        ELSE
            OUTPUT: "ERROR: to many jets, the max capacity is" +maxJetCap+ "."

OTHER METHODS:

SUBMODULE: clone
    IMPORT: none
    EXPORT: cloneShipStorage (Object)
    ASSERTION: returns a cloned object of the current object

    ALGORITHM:
        CONSTRUCT cloneShipStorage USING ALTERNATE CONSTRUCTOR withS
            -(Interger) countSubs 
            -(Interger) countJets 
            -(ARRAY OF subMarine object) storeSubs [] 
            -(ARRAY OF fighterJet object) storeJets []
************************** I am bit confused with this submodule below**********
SUBMODULE: equals
    IMPORT: inObjct (object)
    EXPORT: isSame (boolean)
    ASSERTION: two ship storages are the same if they can store submarines and 
               jets and they have the same storage capacity

    ALGORITHM:
        isSame := FALSE
        IF (inObj ISA shipStorageClass) THEN
            inShipStorage := (Convert to shipStorageClass)inObjct
            isSame := ((LENGTH)storeSubs EQUALS 
                      (LENGTH)inShipStorage.getStoreSubs <- none) AND
                      ((LENGTH)storeJets EQUALS 
                      (LENGTH)inShipStorage.getStoreJets <- none)
        END IF

SUBMODULE: toStringSub
    IMPORT: none
    EXPORT: str [] (String) 
    ASSERTION:

    ALGORITHM:
        
        COMMENT: The +1 for the size of subInfo is used to reserve an extra spot
                 in str to store the information telling the user how many 
                 submarines they're in total.
        
        subInfo := maxSubCap + 1
        (String) str [] := SIZE of subInfo
        str.getStoreSubs <- none
        
        str[0] := "The submarine storage has " +calcTolSubs+ "submarines. The 
                 storage consist of the following submarines: "
        
        FOR ((Interger) ii = 0 TO subInfo -1 CHANGEBY 1) THEN
            
            COMMENT: I am making an extra counter called subCount whihc starts 
                     at 1 because the index of str is already preserved to 
                     to display the total amount of submarines in the storage.

            subCount := 1
            str[subCount] := 
        
        COMMENT: I have subtracted - 1 from subInfo to avoid an out of bounds 
                 indes as the index of an array  starts at 0

        FOR ((Interger)ii = 0 TO subInfo - 1 CHANGEBY 1) THEN
           str[ii] := 

SUBMODULE: toStringJet
    IMPORT: none
    EXPORT: str [] (String)
    ASSERTION:

    ALGORITHM:

SUBMODULE: toString
    IMPORT: none
    EXPORT: str [] (String)
    ASSERTION:

    ALGORITHM:
        
        (String) strSubs [] := SIZE of maxSubCap
        (String) strJets [] := SIZE of maxJetCap 
        (String str [] := SIZE of (maxSubCap + maxJetCap)

        
       str := "The ship " +serialNum+ " was comissioned in " +year+ ", its
               engine has " +cylinders+ " cylinders and runs on " +fuel+ "fuel." 
               "It is a fighter jet with a wing span of " +wingSpan+ " metres and 
                "equiped with"  +ordance+ "."

SUBMODULE: toFileString
    IMPORT: none
    EXPORT: str (String) 
    ASSERTION:

    ALGOTITHM:
        str := "F, " +serialNum+ ", " +year+ ", " +cylinders+ ", " +fuel+ ", " 
               "," +wingSpan+ ", " +ordance+ "."
