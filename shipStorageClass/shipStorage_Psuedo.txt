CLASS: shipStorageArrayClass

PUBLIC CLASS CONSTANTS: 
    
    COMMENT: I have made two maxiumum capcity to make refactoring and
             expandibility of the code easier in the future, and to allow the
             user to have a non 1:1 split of the capacity between submarines adnd
             jets.

    (Interger) MAXSUBCAP := 15
    (Interger) MAXJETCAP := 15

CLASS FIELDS:

    (Interger) countSubs 
    (Interger) countJets 
    (ARRAY OF subMarine object) storeSubs [] 
    (ARRAY OF fighterJet object) storeJets []

COSTRUCTORS:

Defualt:
    IMPORT: none
    EXPORT: none
    ASSERTION: count varibales of zero and empty arrays of the maximum capacity
                variables is valid defualt sate.

    ALGORITHM:
        countSubs := 0 
        countJets := 0 
        storeSubs[] := an EMPTY array of SIZE MAXSUBCAP
        storeJets[] := an EMPTY array of SIZE MAXJETCAP

Alternate
    IMPORT: (subMarine object) inSub 
            (fighterJet object) inJet 
    EXPORT: none
    ASSERTIONS: creates an object if the imports are valid in the next array 
                index available, otherwise it will FAIL

    ALGORITHM:

        IF (validateSubObjct <- inSub) THEN
            IF (validateJetObjct <- inJet) THEN
                storeSub[countSubs] := inSub
                storeJet[countJets] := inJet 
                countSubs := countSubs + 1
                countJets := countJets + 1

        ELSE
            FAIL
        END IF ELSE

Copy:
    IMPORT: inShipStorage (shipStorageArrayClass)
    EXPORT: none
    ASSERTION: creates an object which is identical to the imported object

    ALGORITHM:

        storeSubs[] := inShipStorage.getStoreSubs <- none
        storeJets[] := inShipStorage.getStoreJets <- none

ACCESSORS

SUBMODULES: getStoreSubs
    IMPORT: none
    EXPORT: storeSubs (address of storeSubs object in memory) 
    ASSERTION: returns the elements which were last store storeSubs object

SUBMODULE: getStoreJets
    IMPORT: none
    EXPORT: storeJets (address of storeJets object in memory)
    ASSERTION: returns the elemnts which were last sttore in storeSubs object 

SUBMODULE: getLastSub
    IMPORT: none
    EXOPORT: sub (subMarine Object)

    ALGORITHM:
        COMMENT: I have subtracted one because the other constructors (i.e. 
                 alternate constructor) will move the index  of the count 
                 variable to the next available index, hence you have to 
                 subtract one to get the last stored submarine

        sub := storeSub[countSubs - 1]

SUBMODULE: getLastjet
    IMPORT: none
    EXPORT: jet (fighterJet object)

    ALGORITHM
        
        COMMENT: I have subtracted one because the other constructors (i.e. 
                 alternate constructor) will move the index of the count 
                 variable to the next available index, hence you have to 
                 subtract one to get the last stored jet

        jet := storeJet[countJets - 1]

MUTATORS:

SUBMODULE: setStoreSubs
    IMPORT: inStoreSubs (address of inStoreSubs in memory)
    EXPORT: none
    ASSERTION: if the elements and array found at the specified address is 
               valid. setStoreJets will be valid, otherwise it will fail 

    ALGORITHM:
        IF (validateStoreSubs <- inStoreSubs) THEN 
            storeSubs := inStoreSubs
        ELSE
            FAIL
        END IF ELSE

SUBMODULE: setStoreJets
    IMPORT: inStoreJets (address of inStoreJers in memorty)
    EXPORT: none 
    ASSERTION: if the elements and array found at the specified adress is
               valid. setStoreJets will be valid, otherwise it will fail

    ALGORITHM:
        IF (validateStoreJets <- inStoreJets) THEN
            storeJets := inStoreJets 
        ELSE
            FAIL
        END IF ELSE

SUBMODULE: addSub
    IMPORT: inSub (subMarine object) , countSubs (Interger)
    EXPORT: none
    ASSERTION: a sub will be added to storeSubs if the inSub is valid, and
                storeSubs hasn't exceeded the MAXSUBCAP

    ALGORITHM:
        IF (validateSub <- inSub) THEN
            IF (countSubs < MAXSUBCAP) THEN
                
                storeSubs[countSubs] := inSub

                COMMENT: I am incrementing countSub by 1, to go to the next
                         vaccant index of the storeSub

                countSub := countSubs + 1
            ELSE
                FAIL "ERROR: The storage of the submarines is full."
        ELSE
            FAIL "ERROR: not a submarine"
        END IF ELSE 
         
SUBMODULE: addJet
    IMPORT: inJet (jetFighter object) , countJets (interger) 
    EXPORT: none
    ASSERTION: a jet will be added to storeJEts if the inJet is valid, and 
               storeSubs hasn't exceeded MAXJETCAP

    ALGORITHM:
        IF (validateJet <- inJet) THEN 
            IF (countJets < MAXJETCAP) THEN 

                storeJets[countJets] := inJet

                COMMENT: I am incemention countJets by 1, to go to the next 
                         vaccant index of the storeJets

                countJets := countJets + 1
            ELSE
                FAIL "ERROR: storage of fighter jets is full"
        ELSE
            FAIL "ERROR: not a fighter jet" 
        END IF ELSE

DOING METHODS:

SUBMODULE: destinationCheck *** yet to be implemented

SUBMODULE: findDuplicates *** yet  to be implemented
    
SUBMODULE: calcTolShips
    IMPORT: countSubs (interger), countJets (integer)
    EXPORT: tolShips

    ALGORITHM:
        
        tolShips := (calcTolSubs <- countSubs) + (calcTolJets <- countJets)          
    
SUBMODULE: calcTolSubs
    IMPORT: countSubs
    EXPORT: tolSubs 
    
    ALGORITHM:
       
        COMMENT: the reason why I subtract 1 is because the other submodules
                 are designed to go to the next index available of storeSubs.
                 Hence to get how much ships are avaliable, you have to 
                 subtract 1. But, if the count variables haven't be
                 used (i.e. they're zero) then they're no ships stored, 
                 hence it is 0

        IF (countSubs doesn't EQUAL 0) THEN
            countSubs := countSubs -1 
            tolSubs := countSubs
        ELSE
            tolSubs := countSub
        END IF ELSE    

SUBMODULE: calcTolJets
    IMPORT: countJets
    EXPORT: tolJets
    
    ALOGRITHM:

        COMMENT: the reason why I subtract 1 is because the other submodules
                 are designed to go to the next index available of storeSubs.
                 Hence to get how much ships are avaliable, you have to 
                 subtract 1. But, if the count variables haven't be
                 used (i.e. they're zero) then they're no ships stored, 
                 hence it is 0

        IF (countJets doesn't EQUAL 0) THEN

            countJets := countJets -1
            tolJets := countJets
        ELSE
            tolJets := countSub
        END IF ELSE


PRIVATE SUBMODULES: 

SUBMODULE: validateStoreSubs
    IMPORT: inStoreObect (address of inStoreSubs in memory)
    EXPORT: isValid (Boolean)
    ASSERTION: If the address of inStoreSubs is an array of MAXSUBCAP elements, 
               and it's a SubMarine object it's a valid inStoreSubs

    ALGORITHM:

        isValid := FALSE
        IF (inStoreObjct ISA subMarineClass) THEN
            IF (inStoreObjct LENGTH EQUALS to MAXSUBCAP)               
                isValid := TRUE
            ELSE
                OUTPUT: "ERROR: incorrect storage capacity"
        ELSE
            OUTPUT: "ERROR: not a submarine"

SUBMODULE: validateStoreJets
    IMPORT: inStoreObjct (address of inStoreJets in memory)
    EXPORT: isValid (Boolean)
    ASSERTION: if the address of inStoreJets is an array of MAXJETCAP elements, 
               and it's fighteJet object it's a valid inStoreJet

    ALGORITHM:
        
        isValid := FALSE
        IF (inStoreObjct  ISA fighterJetClass) THEN 
            IF (inStoreObjct LENGTH EQUALS to MAXJETCAP) THEN
                isValid := TRUE
            ELSE
                OUTPUT: "ERROR: incorrect storage capacity"
        ELSE
            OUTPUT: "ERROR: not a fighter jet"
        END IF ELSE 

SUBMODULE: validateSubObjct
    IMPORT: inObjct (subMarine object)
    EXPORT: isValid (Boolean)
    ASSERTION: if inObjct is a subMarine object then it's  valid 

    ALGORITHM:
        
        isValid := FALSE
        IF (inObjct ISA subMarineClass) THEN
            isValid := TRUE
        ELSE
            OUTPUT: "ERROR: not a submarine"
        END IF ELSE

SUBMODULE: validateJetObjct
    IMPORT: inObjct (fighterJet object)
    EXPORT: isValid (Boolean)
    ASSERTION: if inJet is a fighterJet object then it's valid

    ALGORITHM:

        isValid := FALSE
        IF (inObjct ISA fighterJetClass) THEN
            isValid := TRUE
        ELSE
            OUTPUT: "ERROR: not a fighter jet"
        END IF ELSE

OTHER METHODS:

SUBMODULE: clone
    IMPORT: none
    EXPORT: cloneShipStorage (Object)
    ASSERTION: returns a cloned object of the current object

    ALGORITHM:
        CONSTRUCT cloneShipStorage USING ALTERNATE CONSTRUCTOR withS
            -(Interger) countSubs 
            -(Interger) countJets 
            -(ARRAY OF subMarine object) storeSubs [] 
            -(ARRAY OF fighterJet object) storeJets []

SUBMODULE: equals
    IMPORT: inObjct (object)
    EXPORT: isSame (boolean)
    ASSERTION: two ship storages are the same if they can store submarines and 
               jets and they have the same storage capacity with the same 
               storage distrubution

    ALGORITHM:
        isSame := FALSE
        IF (inObj ISA shipStorageArrayClass) THEN
            inShipStorage := (Convert to shipStorageArrayClass)inObjct
            isSame := ((LENGTH)storeSubs EQUALS 
                      (LENGTH)inShipStorage.getStoreSubs <- none) AND
                      ((LENGTH)storeJets EQUALS 
                      (LENGTH)inShipStorage.getStoreJets <- none)
        END IF

SUBODULE: equalsArray 
    IMPORT: arrayOne (Object), arrayTwo (object Two)
    EXPORT: isValid (Boolean)
    ASSERTION: if two array objects are the same class type and length, and have
               the same objects in the array and it's valid

    ALGORITHM:
        
        isValid := FALSE
        
        IF (length of arrayOne is EQUAL to length of arrayTwo) THEN
            isValid :=   TRUE
            
            COMMENT: searching through both arrays to ensure that they have
                     the same conetents in the array 
            
            (Interger) compareElements := 0
            
            DO
                isSame := arrayOne[compareElements].equals
                                                   (arrayTwo[compareElements])
                compareElements := compareElements + 1
            WHILE isSame < LENGTH of arrayOne
        ELSE
            OUTPUT: "ERROR: the array objects are not the same"
        END IF ELSE

 *********************** I might move this type of code straight
to the user Intefac ***********************************************************       

SUBMODULE: toStringSubArray
    IMPORT: none
    EXPORT: str [] (address of str in memory of the data type string) 
    ASSERTION:

    ALGORITHM:
            
            str [] := SIZE of MAXSUBCAP

            COMMENT: I am subtracting one, so the for loop deosn't try to search
                     outside the indexs of the str arrays as its index starts at
                     0

            FOR ((Interger) ii := 0 TO MAXSUBCAP -1 CHNAGEBY 1) THEN
                st[ii] := storeSubs[ii].toString
            END FOR        

SUBMODULE: toStringJet
    IMPORT: none
    EXPORT: str [] (address of str in memory of the data type string)
    ASSERTION:

    ALGORITHM:
        
        str [] := SIZE of MAXJETCAP

        COMMENT: I am subtracting one, so the for loop doesn't try to search 
                 outside the indexs of the str array as its indes starts at 0

        FOR ((Interger) ii = 0 TO MAXJETCAP - 1 CHANGEBY 1) THEN
            str [ii] := storeSubs[ii].toString
        END FOR
*************************end of useless code ***********************************
SUBMODULE: toStringArry
    IMPORT: none
    EXPORT: strArry [] (String)
    ASSERTION:

    ALGORITHM:
        
        COMMENT: I am adding an extra 1 to tolShipsInfo. Because, I want an 
                 extra index to store the summary of the ship storage units
                 (i.e. how many ships they're in total. How many jets they're, 
                 and how many submarines they're)

        (Interger) tolShipsInfo := MAXSUBCAP + MAXSUBJET + 1

        (String) strArry [] := SIZE of tolShipInfo 

        str [0] := "The hanger contains " +calcTolShips+ " ships. There's " 
                    +calcTolSubs+ " submarines, and there's " +calcTolJets+ 
                    "fighter jets in the hanger"
        
        COMMENT: I am starting the looping condition at 1, becasue the 0 index
                 is reserved for the summary of the arrays, and I am subtracting
                 one so the for loop doesn't try to look outside the array as
                 the index of an array starts at 1

        FOR ((Interger)ii:= 1 TO MAXSUBCAP -1 CHNAGEBY 1
            strArry [ii] :=  storeSubs[ii].toString
        END FOR

        FOR (MAXSUBCAP - 1 TO tolShipsInfo - 1 CHANGEBY 1
            strArry [ii] :=  storeJets[ii].toString
        END FOR 
