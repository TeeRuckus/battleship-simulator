CLASS: shipStorageClass 

CLASS FIELDS:
    (ARRAY OF subMarine object) storeSubs [] := SIZE of array is 15 
                                                      elements
    (ARRAY OF fighterJet object) storeJets [] := SIZE of array is 15 
                                                       elements
    (Interger) countSubMarines 
    (Interger) countFighterJets 

COSTRUCTORS:

Defualt:
    IMPORT: none
    EXPORT: none
    ASSERTION: an empty storage of submarines and fighter jets, and count
               variables of 1 for countSubMarines and countFighterJets is valid;

    ALGORITHM:
        storeSubs := AN EMPTY ARRAY
        storeJets := AN EMPTY ARRAY
        countSubs := 1
        countJets := 1 

Alternate
    IMPORT: (subMarine object) inSub [], 
            (fighterJet object) inJet []
    EXPORT: none
    ASSERTIONS: creates an object if the imports are valid, otherwise it will
                FAIL

    ALGORITHM:

        IF (valiadateStoreSubss <- inSubMarine) THEN
            IF (validateStoreJets <- inFighterJets THEN
                storeSub[countSubs - 1] := inSub
                storeJet[countJets - 1] := inJet 
                countSubs := countSubs + 1
                countJets := countJets + 1

        ELSE
            FAIL
        END IF ELSE

Copy:
    IMPORT: inShipStorage (shipStorageClass)
    EXPORT: none
    ASSERTION: creates an object which is identical to the imported object

    ALGORITHM:

        storeSubs := inShipStorage.getStoreSubs <- none
        storeJets := inShipStorage.getStoreJets <- none

ACCESSORS

SUBMODULES: getStoreSubs
    IMPORT: none
    EXPORT: storeSubs (address of storeSubs object in memory) 
    ASSERTION: returns the elements which were last store in storeSubs object

SUBMODULE: getStoreJets
    IMPORT: none
    EXPORT: storeJets (address of storeJets object in memory)
    ASSERTION: returns the elemnts which were last sttore in storeSubs object 

MUTATORS:

SUBMODULE: setStoreSubs
    IMPORT: inStoreSubs (Real)
    EXPORT: none
    ASSERTION: sets the serial number to inSerialNum if it's valid, otherwise
                it fails

    ALGORITHM:
        IF (validateSerialNum <- inSerialNum) THEN
            serialNum := inSerialNum
        ELSE
            FAIL
        END IF ELSE


SUBMODULE: setYear
    IMPORT: inYear (interger)
    EXPORT: none
    ASSERTION: set year to inYear if it's valid, otherwise it will fail

    ALGORITHM:
        IF (validateYear <- inYear) THEN
            year := inYear
        ELSE
            FAIL
        END IF ELSE

SUBMODULE: setOrdance
    IMPORT: inOrdance (String)
    EXPORT: none
    ASSERTION: set ordance to to inOrdance if it's valid, otherwise it will fail

    ALGORITHM:
        IF (validateOrdance <- inOrdance) THEN
            ordance := inOrdance
        ELSE
            FAIL
        END IF ELSE

SUBMODULE: setWingSpan
    IMPORT: inWingSpan (Real)
    EXPORT: none
    ASSERTION: set wingspan to inWingSpan if it's valid, otherwise

    ALGORITHM:
        IF (validateWingSpan <- inWingSpan) THEN
            wingSpan :=  inWingSpan
        ELSE
            FAIL
        END IF ELSE

DOING METHODS:

    SUBMODULE: calcTravel (*** I cannot impliment this yet, as my knowledge on
                            how to is limited ***)

PRIVATE SUBMODULES:

    SUBMODULE: validateSerialNum
        IMPORT: inSerialNum (Real)
        EXPORT: isValid (Boolean)
        ASSERTION: validates serial numbers as true whereby its first three
                   digits are between 100 to 200 (inclusive), and the last three
                   digits are between 001 - 999 (inclusive), otherwise it will
                   validate them as false.

        ALGORITHM:
            isValid := FALSE
            
            wholePart := (Interger)inSerialNum 
            decimalPart := (interger)(inSerialNum * 100) MOD 1000
            
            IF (100 <= wholePart <= 300) THEN
                IF (1 <= decimalPart <= 999) THEN
                    isValid :-= TRUE 
                END IF
            END IF

    SUBMODULE: validateYear
        IMPORT: inYear (intergers)
        EXPORT: isValid (Boolean)
        ASSERTION: A commission year between 1950 to 2022 (interger) will be
                   valid, otherwise an error will be thrown to the user

        ALGORITHM:
            isValid := FALSE

            IF ( 1950 <= inYear <= 2022) THEN
                isValid :=   TRUE
            END IF


    SUBMODULE: validateOrdance
        IMPORT: inOrdance (String)
        EXPORT: isValid (boolean)
        ASSERTION: it will only validate inOrdance if it has a string describing
                   the ordance of the fighter jet

        ALGORITHM:
           isValid := False
           
            IF (LENGTH of inOrdance doesn't equals to 0) THEN
                isValid := True
            END IF     


    SUBMODULE: validateWingSpan
        IMPORT: inWingSpan (Real)
        EXPORT: isValid (Boolean)
        ASSERTION: a wingspan of between 2.2 and 25.6 will be valid 
                   otherwise, an error will be thrown to the user

        ALGORITHM:
            isValid := FALSE

            IF (2.20 <= inWingSpan <= 25.6) THEN
                isValid := TRUE
            END IF

OTHER METHODS:

SUBMODULE: clone
    IMPORT: none
    EXPORT: cloneFighterJet (Object)
    ASSERTION: returns a cloned object of the current object

    ALGORITHM:
        CONSTRUCT cloneFighterJet USING ALTERNATE CONSTRUCTOR with
            -serialNum
            -year
            -ordance
            -wingSpan

SUBMODULE: equals
    IMPORT: inObjct (object)
    EXPORT: isSame (boolean)
    ASSERTION: two fighter jets are interchangable if they have the same ordance, and
                wingspan

    ALGORITHM:
        isSame := FALSE
        IF (inObj ISA fighterJetClass) THEN
            inFighterJet  := (Convert to fighterJetClass)inObjct
            isSame := (ordance EQUALS inFighterJet.getOrdance <- none) AND
                      (wingSpan EQUALS inFighterJet.getWingSpan <- none)
        END IF


SUBMODULE: toString
    IMPORT: none
    EXPORT: str (String)
    ASSERTION:

    ALGORITHM:
       str := "The ship " +serialNum+ " was comissioned in " +year+ ", its
               engine has " +cylinders+ " cylinders and runs on " +fuel+ "fuel." 
               "It is a fighter jet with a wing span of " +wingSpan+ " metres and 
                "equiped with"  +ordance+ "."

SUBMODULE: toFileString
    IMPORT: none
    EXPORT: str (String) 
    ASSERTION:

    ALGOTITHM:
        str := "F, " +serialNum+ ", " +year+ ", " +cylinders+ ", " +fuel+ ", " 
               "," +wingSpan+ ", " +ordance+ "."
