CLASS: shipStorage

PUBLIC CLASS CONSTANTS:

    COMMENT: I have made two maxiumum capcity to make refactoring and
             expandibility of the code easier in the future, and to allow the
             user to have a non 1:1 split of the capacity between submarines and
             jets.

    (Integer) MAXCAP := 15

CLASS FIELDS:

    (Integer) countSubs
    (Integer) countJets
    (ARRAY OF subMarine object) storeSubs []
    (ARRAY OF fighterJet object) storeJets []

COSTRUCTORS:

Defualt:
    IMPORT: none
    EXPORT: none
    ASSERTION: count varibales of zero and empty arrays of the maximum capacity
                variables is valid defualt sate.

    ALGORITHM:
        countSubs := 0
        countJets := 0
        storeSubs[] := an EMPTY array of SIZE MAXCAP
        storeJets[] := an EMPTY array of SIZE MAXCAP

ACCESSORS

SUBMODULES: getStoreSubs (subMarineClass object)
    IMPORT: none
    EXPORT: storeSubs (address of storeSubs object in memory)
    ASSERTION: returns the elements which were last store storeSubs object

SUBMODULE: getStoreJets (fighterJetClass object)
    IMPORT: none
    EXPORT: storeJets (address of storeJets object in memory)
    ASSERTION: returns the elemnts which were last sttore in storeSubs object

SUBMODULE: getLastSub (subMarineClass object)
    IMPORT: none
    EXOPORT: sub (subMarine Object)

    ALGORITHM:
        COMMENT: I have subtracted one because the other constructors (i.e.
                 alternate constructor) will move the index  of the count
                 variable to the next available index, hence you have to
                 subtract one to get the last stored submarine

        sub := storeSub[countSubs - 1]

SUBMODULE: getLastjet (fighterJetClass Object)
    IMPORT: none
    EXPORT: jet (fighterJet object)

    ALGORITHM

        COMMENT: I have subtracted one because the other constructors (i.e.
                 alternate constructor) will move the index of the count
                 variable to the next available index, hence you have to
                 subtract one to get the last stored jet

        jet := storeJet[countJets - 1]

MUTATORS:

SUBMODULE: setStoreSubs 
    IMPORT: inStoreSubs (address of inStoreSubs in memory) ****recondsider the inStoreSubs
    EXPORT: none
    ASSERTION: if the elements and array found at the specified address is
               valid. setStoreJets will be valid, otherwise it will fail

    ALGORITHM:
        IF (validateStoreSubs <- inStoreSubs) THEN
            storeSubs := inStoreSubs
        ELSE
            FAIL
        END IF ELSE

SUBMODULE: setStoreJets 
    IMPORT: inStoreJets (address of inStoreJers in memorty)
    EXPORT: none
    ASSERTION: if the elements and array found at the specified adress is
               valid. setStoreJets will be valid, otherwise it will fail

    ALGORITHM:
        IF (validateStoreJets <- inStoreJets) THEN
            storeJets := inStoreJets
        ELSE
            FAIL
        END IF ELSE

SUBMODULE: addShipSubmarine (this is the submarine version)
    IMPORT: inSub (subMarine object) , countSubs (Integer)
    EXPORT: none
    ASSERTION: a sub will be added to storeSubs if the inSub is valid, and
                storeSubs hasn't exceeded the MAXCAP

    ALGORITHM:
        IF (validateSub <- inSub) THEN
                storeSubs[countSubs] := inSub

                COMMENT: I am incrementing countSub by 1, to go to the next
                         vaccant index of the storeSub

                countSub := countSubs + 1
            ELSE
                FAIL "ERROR: The storage of the submarines is full."
        ELSE
            FAIL "ERROR: not a submarine"
        END IF ELSE

SUBMODULE: addShipFighterJet (this is the fighter jet version) -> we will 
           change this when we do inheritance) 
    IMPORT: inJet (jetFighter object) , countJets (integer)
    EXPORT: none
    ASSERTION: a jet will be added to storeJEts if the inJet is valid, and
               storeSubs hasn't exceeded MAXCAP

    ALGORITHM:
        IF (validateJet <- inJet) THEN
                storeJets[countJets] := inJet

                COMMENT: I am incemention countJets by 1, to go to the next
                         vaccant index of the storeJets

                countJets := countJets + 1
            ELSE
                FAIL "ERROR: storage of fighter jets is full"
        ELSE
            FAIL "ERROR: not a fighter jet"
        END IF ELSE

DOING METHODS:

SUBMODULE: destinationCheckSubmarine
    IMPORT: (integer) distance
    EXORTS: timeHours (Real)
    PURPOSE:

    ALGORITHM:
        
        FOR((integer)ii := 0 TO MAXCAP (exclusive) CHANGEBY 1) THEN 

SUBMODULE: calcTravelTimeSubmarine
    IMPORT: (Integer) distance, (Integer) cylinders, (Real) maxDepth
    EXPORT: timeHours (Real) 
    PUROSE: is to calculate the travel time of submarine in hours 
    
    ALGORITHM:
    
        (Real) ratio := ((Real)distance/(Real)(cylinders))
        (Real) denom := (10.00 + (maxDepth * -1.00))
        (Real) invDenom := 1.00/denom 
        
        timeHours := ratio*invDenom
        
SUBMODULE: destinationCheckFighterJet

SUBMODULE: calcTravelTimeFighterJets
    IMPORT: (Integer) distance, (Real) wingSpan, (Integer) cylinders
    EXPORT: timeHours
    PURPOSE: is to calculate the tracel time of the fighter jet in hours

    ALGORITHM:

        (Real) denom := wingSpan * (Real) cylinders * 150.00 
        timeHours := (Real)distance/denom

SUBMODULE: findDuplicateSubs
    IMPORTS: none
    EXPORT: dupilicates[] (subMarineClass object)
    ASSERTION:

    ALGORITHM:
        
        COMMENT: The multipilcation by 2 is done because it allows the 
                 duplicates array store the actual ship and it's dupilcate in 
                 the indexes next to each other 

        (object) duplicates [] := SIZE of MAXCAP * 2
        
        FOR ((integer) ii := 0 TO MAXCAP (exclusive) CHANGEBY 1) THEN

            COMMENT: I am starting the looping variable at one because 1 don't
                     want the programme to store itself as a dupilcate, hence
                     it will search for objects after itself

            FOR((integer) jj := 1 TO LENGTH of storeSub (exclusive)
                                 CHANGEBY 1) THEN
                IF (storeSubs[ii].equals(storeSubs[jj])) THEN
                    duplicate[ii] := storeSubs
                    duplicate[jj] := storeSubs[jj]
                END IF

        END FOR

SUBMODULE: findDuplicateJets
    IMPORTS: none
    EXPORT: dupilicates[] (fighterJetClass object) 
    ASSERTION:

    ALGORITHM:

    (object) duplicates [] := SIZE of MAXCAP * 2 
        
        FOR ((integer) ii := 0 TO MAXCAP (exclusive) CHANGEBY 1) THEN

            COMMENT: I am starting the looping variable at one because I don't
                     want the programme to store itself as a dupilcate, hence
                     it will search for objects after itself

            FOR((integer) jj := 1 TO LENGTH of storeJet (exclusive)
                                 CHANGEBY 1) THEN
                IF (storeJets[ii].equals(storeJets[jj])) THEN
                    duplicate[ii] := storeJets
                    duplicate[jj] := storeJets[jj]
                END IF
            END FOR

SUBMODULE: calcTolShips
    IMPORT: countSubs (integer), countJets (integer)
    EXPORT: tolShips (integer)

    ALGORITHM:

        tolShips := countSubs + countJets 

PRIVATE SUBMODULES:

SUBMODULE: validateStoreSubs
    IMPORT: inStoreSub (subMarineClass) 
    EXPORT: isValid (Boolean)
    ASSERTION: If the address of inStoreSubs is an array of MAXCAP elements,
               and it's a SubMarine object it's a valid inStoreSubs

    ALGORITHM:

        isValid := FALSE
        IF (inStoreObjct ISA subMarineClass) THEN
            IF (inStoreObjct LENGTH EQUALS to MAXCAP)
                isValid := TRUE
            ELSE
                OUTPUT: "ERROR: incorrect storage capacity"
        ELSE
            OUTPUT: "ERROR: not a submarine"

SUBMODULE: validateStoreJets
    IMPORT: inStoreJet (fighterJetClass)
    EXPORT: isValid (Boolean)
    ASSERTION: if the address of inStoreJets is an array of MAXCAP elements,
               and it's fighteJet object it's a valid inStoreJet

    ALGORITHM:

        isValid := FALSE
        IF (inStoreObjct  ISA fighterJetClass) THEN
            IF (inStoreObjct LENGTH EQUALS to MAXCAP) THEN
                isValid := TRUE
            ELSE
                OUTPUT: "ERROR: incorrect storage capacity"
        ELSE
            OUTPUT: "ERROR: not a fighter jet"
        END IF ELSE

SUBMODULE: validateSub
    IMPORT: inObjct (subMarine object)
    EXPORT: isValid (Boolean)
    ASSERTION: if inObjct is a subMarine object then it's  valid

    ALGORITHM:

        isValid := FALSE
        IF (the inObjct doens't equal to null) THEN 
            IF (checkStoreSubCapacity <- none) THEN
                isValid := TRUE
            END IF
        END IF
    END IF 

SUBMODULE: validateJet
    IMPORT: inObjct (fighterJet object)
    EXPORT: isValid (Boolean)
    ASSERTION: if inJet is a fighterJet object then it's valid

    ALGORITHM:

        isValid := FALSE
        IF(inObjct does not equal to null) THEN
            IF (checkStoreSubCapacity <- none) THEN
                isValid := TRUE
            END IF
        END IF
    END IF 
              
SUBMODULE: checkStoreSubsCapacity
    IMPORT: none
    EXPORT: spaceAvail (Boolean)
    PURPOSE: to check if there's available space in the storeSub array so 
             another ship can be added to the array
    
    ALGORITHM:
        
        spaceAvail := FALSE
        IF (storeSubs[countSubs]) is equal to nothing) THEN
            spaceAvail := TRUE
            countSubs := countSubs + 1 
        END IF

SUBMODULE: checkStoreJetsCapacity
    IMPORT: none 
    EXPORT: spaceAvail  (Boolean) 
    PURPOS: to check if there's available sapce in the storeJets array so 
            another ship can be added to the array 

    ALGORITHM: 
        
            spaceAvail := TRUE
            IF (storeJets[countJets] is equal to nothing) THEN
                spaceAvail := TRUE
                countJets := countJets + 1 
            END IF

OTHER METHODS:

SUBMODULE: clone
    IMPORT: none
    EXPORT: cloneShipStorage (Object)
    ASSERTION: returns a cloned object of the current object

    ALGORITHM:
        CONSTRUCT cloneShipStorage USING ALTERNATE CONSTRUCTOR withS
            -(Integer) countSubs
            -(Integer) countJets
            -(ARRAY OF subMarine object) storeSubs []
            -(ARRAY OF fighterJet object) storeJets []

SUBMODULE: equals
    IMPORT: inObjct (object)
    EXPORT: isSame (boolean)
    ASSERTION: two ship storages are the same if they can store submarines and
               jets and they have the same storage capacity with the same
               storage distrubution

    ALGORITHM:
        isSame := FALSE
        IF (inObj ISA shipStorage) THEN
            inShipStorage := (Convert to shipStorage)inObjct
            isSame := ((LENGTH)storeSubs EQUALS
                      (LENGTH)inShipStorage.getStoreSubs <- none) AND
                      ((LENGTH)storeJets EQUALS
                      (LENGTH)inShipStorage.getStoreJets <- none)
        END IF

SUBODULE: equalsArray
    IMPORT: arrayOne (Object), arrayTwo (object Two)
    EXPORT: isValid (Boolean)
    ASSERTION: if two array objects are the same class type and length, and have
               the same objects in the array and it's valid

    ALGORITHM:

        isValid := FALSE

        IF (length of arrayOne is EQUAL to length of arrayTwo) THEN
            isValid :=   TRUE

            COMMENT: searching through both arrays to ensure that they have
                     the same contents in the array

            (Integer) compareElements := 0

            DO
                isSame := arrayOne[compareElements].equals
                                                   (arrayTwo[compareElements])
                compareElements := compareElements + 1
            WHILE compareElements < LENGTH of arrayOne
        ELSE
            OUTPUT: "ERROR: the array objects are not the same"
        END IF ELSE

 *********************** I might move this type of code straight
to the user Intefac ***********************************************************

SUBMODULE: toStringSubArr
    IMPORT: none
    EXPORT: str [] (address of str in memory of the data type string)
    ASSERTION:

    ALGORITHM:

            str [] := SIZE of MAXCAP

            FOR ((Integer) ii := 0 TO MAXCAP (exclusive) CHNAGEBY 1) THEN
                st[ii] := storeSubs[ii].toString
            END FOR

SUBMODULE: toStringJetArr
    IMPORT: none
    EXPORT: str [] (address of str in memory of the data type string)
    ASSERTION:

    ALGORITHM:

        str [] := SIZE of MAXCAP

        COMMENT: I am subtracting one, so the for loop doesn't try to search
                 outside the indexs of the str array as its indes starts at 0

       FOR ((Integer) ii = 0 TO MAXCAP (exclusive) CHANGEBY 1) THEN
            str [ii] := storeSubs[ii].toString
        END FOR
*************************end of useless code ***********************************
SUBMODULE: toStringArr
    IMPORT: none
    EXPORT: strarr [] (String)
    ASSERTION:

    ALGORITHM:

        COMMENT: I am adding an extra 1 to tolShipsInfo. Because, I want an
                 extra index to store the summary of the ship storage units
                 (i.e. how many ships they're in total. How many jets they're,
                 and how many submarines they're)

        (Integer) tolShipsInfo := MAXCAP + MAXSUBJET + 1

        (String) strarr [] := SIZE of tolShipInfo
        
        shipNum := calcTolShips

        str [0] := "The hanger contains " +shipNum+ " ships. There's "
                    +countSubs+ " submarines, and there's " +countJets+
                    "fighter jets in the hanger"

        COMMENT: I am starting the looping condition at 1, becasue the 0 index
                 is reserved for the summary of the arrays, and I am subtracting
                 one so the for loop doesn't try to look outside the array as
                 the index of an array starts at 1

        FOR ((Integer)ii:= 1 TO MAXCAP (exclusive) CHNAGEBY 1
            strarr [ii] :=  storeSubs[ii].toString
        END FOR

        COMMENT: I used the starting index of (MAXCAP) becasue I want to
                 start adding the information of the fighter jets, to the next
                 vaccant spot after the information of the submarines and it
                 corresponds to MAXCAP

        FOR((integer) ii:= MAXCAP TO tolShipsInfo (exclusive) CHANGEBY 1
            strarr [ii] :=  storeJets[ii].toString
        END FOR
