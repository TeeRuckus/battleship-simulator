CLASS: shipStorage
                throw new IllegalArgumentException("\n 

PUBLIC CLASS CONSTANTS:

    COMMENT: I have made two maxiumum capcity to make refactoring and
             expandibility of the code easier in the future, and to allow the
             user to have a non 1:1 split of the capacity between submarines and
             jets.

    (Interger) MAXSUBCAP := 15
    (Interger) MAXJETCAP := 15

CLASS FIELDS:

    (Interger) countSubs
    (Interger) countJets
    (ARRAY OF subMarine object) storeSubs []
    (ARRAY OF fighterJet object) storeJets []

COSTRUCTORS:

Defualt:
    IMPORT: none
    EXPORT: none
    ASSERTION: count varibales of zero and empty arrays of the maximum capacity
                variables is valid defualt sate.

    ALGORITHM:
        countSubs := 0
        countJets := 0
        storeSubs[] := an EMPTY array of SIZE MAXSUBCAP
        storeJets[] := an EMPTY array of SIZE MAXJETCAP

Alternate
    IMPORT: (subMarine object) inSub
            (fighterJet object) inJet
    EXPORT: none
    ASSERTIONS: creates an object if the imports are valid in the next array
                index available, otherwise it will FAIL

    ALGORITHM:

        IF (validateSubObjct <- inSub) THEN
            IF (validateJetObjct <- inJet) THEN
                storeSub[countSubs] := inSub
                storeJet[countJets] := inJet
                countSubs := countSubs + 1
                countJets := countJets + 1
            ELSE
                FAIL "Invalid fighterJet"
        ELSE
            FAIL "Invalid submarine" 
        END IF ELSE

Copy:
    IMPORT: inShipStorage (shipStorage)
    EXPORT: none
    ASSERTION: creates an object which is identical to the imported object

    ALGORITHM:

        FOR ((integer)ii := 0 TO LENGTH of inShipStorage.MAXSUBCAP (exclusive
                         CHANGEBY 1) 
            THEN
            storeSubs[ii] := inShipStorage.storeSubs[ii]
        END FOR

        FOR ((integer)ii := 0 TO LENGTH of inShipStorage.MAXJETCAP (exclusive) 
            CHANGEBY 1) THEN 
            storejets[ii] := inShipStorage.storeJets[ii]
        END FOR

ACCESSORS

SUBMODULES: getStoreSubs (subMarineClass object)
    IMPORT: none
    EXPORT: storeSubs (address of storeSubs object in memory)
    ASSERTION: returns the elements which were last store storeSubs object

SUBMODULE: getStoreJets (fighterJetClass object)
    IMPORT: none
    EXPORT: storeJets (address of storeJets object in memory)
    ASSERTION: returns the elemnts which were last sttore in storeSubs object

SUBMODULE: getLastSub (subMarineClass object)
    IMPORT: none
    EXOPORT: sub (subMarine Object)

    ALGORITHM:
        COMMENT: I have subtracted one because the other constructors (i.e.
                 alternate constructor) will move the index  of the count
                 variable to the next available index, hence you have to
                 subtract one to get the last stored submarine

        sub := storeSub[countSubs - 1]

SUBMODULE: getLastjet (fighterJetClass Object)
    IMPORT: none
    EXPORT: jet (fighterJet object)

    ALGORITHM

        COMMENT: I have subtracted one because the other constructors (i.e.
                 alternate constructor) will move the index of the count
                 variable to the next available index, hence you have to
                 subtract one to get the last stored jet

        jet := storeJet[countJets - 1]

MUTATORS:

SUBMODULE: setStoreSubs 
    IMPORT: inStoreSubs (address of inStoreSubs in memory) ****recondsider the inStoreSubs
    EXPORT: none
    ASSERTION: if the elements and array found at the specified address is
               valid. setStoreJets will be valid, otherwise it will fail

    ALGORITHM:
        IF (validateStoreSubs <- inStoreSubs) THEN
            storeSubs := inStoreSubs
        ELSE
            FAIL
        END IF ELSE

SUBMODULE: setStoreJets 
    IMPORT: inStoreJets (address of inStoreJers in memorty)
    EXPORT: none
    ASSERTION: if the elements and array found at the specified adress is
               valid. setStoreJets will be valid, otherwise it will fail

    ALGORITHM:
        IF (validateStoreJets <- inStoreJets) THEN
            storeJets := inStoreJets
        ELSE
            FAIL
        END IF ELSE

SUBMODULE: addSub 
    IMPORT: inSub (subMarine object) , countSubs (Interger)
    EXPORT: none
    ASSERTION: a sub will be added to storeSubs if the inSub is valid, and
                storeSubs hasn't exceeded the MAXSUBCAP

    ALGORITHM:
        IF (validateSub <- inSub) THEN
            IF (countSubs < MAXSUBCAP) THEN

                storeSubs[countSubs] := inSub

                COMMENT: I am incrementing countSub by 1, to go to the next
                         vaccant index of the storeSub

                countSub := countSubs + 1
            ELSE
                FAIL "ERROR: The storage of the submarines is full."
        ELSE
            FAIL "ERROR: not a submarine"
        END IF ELSE

SUBMODULE: addJet
    IMPORT: inJet (jetFighter object) , countJets (integer)
    EXPORT: none
    ASSERTION: a jet will be added to storeJEts if the inJet is valid, and
               storeSubs hasn't exceeded MAXJETCAP

    ALGORITHM:
        IF (validateJet <- inJet) THEN
            IF (countJets < MAXJETCAP) THEN

                storeJets[countJets] := inJet

                COMMENT: I am incemention countJets by 1, to go to the next
                         vaccant index of the storeJets

                countJets := countJets + 1
            ELSE
                FAIL "ERROR: storage of fighter jets is full"
        ELSE
            FAIL "ERROR: not a fighter jet"
        END IF ELSE

DOING METHODS:

SUBMODULE: destinationCheck *** yet to be implemented

SUBMODULE: findDuplicateSubs
    IMPORTS: none
    EXPORT: dupilicates[] (Object) 
    ASSERTION:

    ALGORITHM:

        (object) duplicates [] := SIZE of DYNAMIC SIZING
        
        FOR ((integer) ii := 0 TO LENGTH of storeSub(exclusive) CHANGEBY 1) THEN

            COMMENT: I am starting the looping variable at one because 1 don't
                     want the programme to store itself as a dupilcate, hence
                     it will search for objects after itself

            FOR((integer) jj := 1 TO LENGTH of storeSub (exclusive)
                                 CHANGEBY 1) THEN
                IF (storeSubs[ii].equals(storeSubs[jj])) THEN
                    duplicate[ii] := storeSubs
                    duplicate[jj] := storeSubs[jj]
                END IF

        END FOR

SUBMODULE: findDuplicateJets
    IMPORTS: none
    EXPORT: dupilicates[] (Object) 
    ASSERTION:

    ALGORITHM:

    (object) duplicates [] := SIZE of DYNAMIC SIZING
        
        FOR ((integer) ii := 0 TO LENGTH of storeJet (exclusive)
                             CHANGEBY 1) THEN

            COMMENT: I am starting the looping variable at one because I don't
                     want the programme to store itself as a dupilcate, hence
                     it will search for objects after itself

            FOR((integer) jj := 1 TO LENGTH of storeJet (exclusive)
                                 CHANGEBY 1) THEN
                IF (storeJets[ii].equals(storeJets[jj])) THEN
                    duplicate[ii] := storeJets
                    duplicate[jj] := storeJets[jj]
                END IF
            END FOR

SUBMODULE: findDuplicates
    IMPORTS: none
    EXPORT: dupilicates (object)
    ASSERTION

    ALGORITHM:

    (object) duplicates [] := SIZE of DYNAMIC SIZING
   
    
    

SUBMODULE: calcTolShips
    IMPORT: countSubs (integer), countJets (integer)
    EXPORT: tolShips (integer)

    ALGORITHM:

        tolShips := countSubs + countJets 

PRIVATE SUBMODULES:

SUBMODULE: validateStoreSubs
    IMPORT: inStoreSub (subMarineClass) 
    EXPORT: isValid (Boolean)
    ASSERTION: If the address of inStoreSubs is an array of MAXSUBCAP elements,
               and it's a SubMarine object it's a valid inStoreSubs

    ALGORITHM:

        isValid := FALSE
        IF (inStoreObjct ISA subMarineClass) THEN
            IF (inStoreObjct LENGTH EQUALS to MAXSUBCAP)
                isValid := TRUE
            ELSE
                OUTPUT: "ERROR: incorrect storage capacity"
        ELSE
            OUTPUT: "ERROR: not a submarine"

SUBMODULE: validateStoreJets
    IMPORT: inStoreJet (fighterJetClass)
    EXPORT: isValid (Boolean)
    ASSERTION: if the address of inStoreJets is an array of MAXJETCAP elements,
               and it's fighteJet object it's a valid inStoreJet

    ALGORITHM:

        isValid := FALSE
        IF (inStoreObjct  ISA fighterJetClass) THEN
            IF (inStoreObjct LENGTH EQUALS to MAXJETCAP) THEN
                isValid := TRUE
            ELSE
                OUTPUT: "ERROR: incorrect storage capacity"
        ELSE
            OUTPUT: "ERROR: not a fighter jet"
        END IF ELSE

SUBMODULE: validateSubObjct
    IMPORT: inObjct (subMarine object)
    EXPORT: isValid (Boolean)
    ASSERTION: if inObjct is a subMarine object then it's  valid

    ALGORITHM:

        isValid := FALSE
        IF (inObjct ISA subMarineClass) THEN
            isValid := TRUE
        ELSE
            OUTPUT: "ERROR: not a submarine"
        END IF ELSE

SUBMODULE: validateJetObjct
    IMPORT: inObjct (fighterJet object)
    EXPORT: isValid (Boolean)
    ASSERTION: if inJet is a fighterJet object then it's valid

    ALGORITHM:

        isValid := FALSE
        IF (inObjct ISA fighterJetClass) THEN
            isValid := TRUE
        ELSE
            OUTPUT: "ERROR: not a fighter jet"
        END IF ELSE

OTHER METHODS:

SUBMODULE: clone
    IMPORT: none
    EXPORT: cloneShipStorage (Object)
    ASSERTION: returns a cloned object of the current object

    ALGORITHM:
        CONSTRUCT cloneShipStorage USING ALTERNATE CONSTRUCTOR withS
            -(Interger) countSubs
            -(Interger) countJets
            -(ARRAY OF subMarine object) storeSubs []
            -(ARRAY OF fighterJet object) storeJets []

SUBMODULE: equals
    IMPORT: inObjct (object)
    EXPORT: isSame (boolean)
    ASSERTION: two ship storages are the same if they can store submarines and
               jets and they have the same storage capacity with the same
               storage distrubution

    ALGORITHM:
        isSame := FALSE
        IF (inObj ISA shipStorage) THEN
            inShipStorage := (Convert to shipStorage)inObjct
            isSame := ((LENGTH)storeSubs EQUALS
                      (LENGTH)inShipStorage.getStoreSubs <- none) AND
                      ((LENGTH)storeJets EQUALS
                      (LENGTH)inShipStorage.getStoreJets <- none)
        END IF

SUBODULE: equalsArray
    IMPORT: arrayOne (Object), arrayTwo (object Two)
    EXPORT: isValid (Boolean)
    ASSERTION: if two array objects are the same class type and length, and have
               the same objects in the array and it's valid

    ALGORITHM:

        isValid := FALSE

        IF (length of arrayOne is EQUAL to length of arrayTwo) THEN
            isValid :=   TRUE

            COMMENT: searching through both arrays to ensure that they have
                     the same contents in the array

            (Interger) compareElements := 0

            DO
                isSame := arrayOne[compareElements].equals
                                                   (arrayTwo[compareElements])
                compareElements := compareElements + 1
            WHILE isSame < LENGTH of arrayOne
        ELSE
            OUTPUT: "ERROR: the array objects are not the same"
        END IF ELSE

 *********************** I might move this type of code straight
to the user Intefac ***********************************************************

SUBMODULE: toStringSubArr
    IMPORT: none
    EXPORT: str [] (address of str in memory of the data type string)
    ASSERTION:

    ALGORITHM:

            str [] := SIZE of MAXSUBCAP

            FOR ((Interger) ii := 0 TO MAXSUBCAP (exclusive) CHNAGEBY 1) THEN
                st[ii] := storeSubs[ii].toString
            END FOR

SUBMODULE: toStringJetArr
    IMPORT: none
    EXPORT: str [] (address of str in memory of the data type string)
    ASSERTION:

    ALGORITHM:

        str [] := SIZE of MAXJETCAP

        COMMENT: I am subtracting one, so the for loop doesn't try to search
                 outside the indexs of the str array as its indes starts at 0

       FOR ((Interger) ii = 0 TO MAXJETCAP (exclusive) CHANGEBY 1) THEN
            str [ii] := storeSubs[ii].toString
        END FOR
*************************end of useless code ***********************************
SUBMODULE: toStringArr
    IMPORT: none
    EXPORT: strarr [] (String)
    ASSERTION:

    ALGORITHM:

        COMMENT: I am adding an extra 1 to tolShipsInfo. Because, I want an
                 extra index to store the summary of the ship storage units
                 (i.e. how many ships they're in total. How many jets they're,
                 and how many submarines they're)

        (Interger) tolShipsInfo := MAXSUBCAP + MAXSUBJET + 1

        (String) strarr [] := SIZE of tolShipInfo

        str [0] := "The hanger contains " +calcTolShips+ " ships. There's "
                    +countSubs+ " submarines, and there's " +countJets+
                    "fighter jets in the hanger"

        COMMENT: I am starting the looping condition at 1, becasue the 0 index
                 is reserved for the summary of the arrays, and I am subtracting
                 one so the for loop doesn't try to look outside the array as
                 the index of an array starts at 1

        FOR ((Interger)ii:= 1 TO MAXSUBCAP (exclusive) CHNAGEBY 1
            strarr [ii] :=  storeSubs[ii].toString
        END FOR

        COMMENT: I used the starting index of (MAXSUBCAP) becasue I want to
                 start adding the information of the fighter jets, to the next
                 vaccant spot after the information of the submarines and it
                 corresponds to MAXSUBCAP

        FOR((integer) ii:= MAXSUBCAP TO tolShipsInfo (exclusive) CHANGEBY 1
            strarr [ii] :=  storeJets[ii].toString
        END FOR
